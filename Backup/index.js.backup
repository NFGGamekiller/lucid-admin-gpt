require('dotenv').config();
const { Client, GatewayIntentBits, EmbedBuilder, ActivityType } = require('discord.js');
const enhancedGptHandler = require('./utils/enhancedConversationalGPTHandler');

// Validate environment variables
const requiredEnvVars = ['DISCORD_TOKEN', 'OPENAI_API_KEY'];
const missingEnvVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingEnvVars.length > 0) {
  console.error('âŒ Missing required environment variables:', missingEnvVars.join(', '));
  console.error('Please check your .env file and ensure all required variables are set.');
  process.exit(1);
}

// Create client with necessary intents
const client = new Client({ 
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMembers
  ] 
});

// Active conversations tracker
const activeConversations = new Map();
const CONVERSATION_TIMEOUT = 60000; // 60 seconds

class EnhancedConversationSession {
  constructor(userId, channelId) {
    this.userId = userId;
    this.channelId = channelId;
    this.startTime = Date.now();
    this.lastActivity = Date.now();
    this.messageHistory = [];
    this.ruleTopics = new Set(); // Track discussed rule topics
    this.concepts = new Set(); // Track discussed concepts
    this.timeout = null;
    this.resetTimeout();
  }

  addMessage(role, content) {
    this.messageHistory.push({ 
      role, 
      content, 
      timestamp: Date.now() 
    });
    this.lastActivity = Date.now();
    this.resetTimeout();
    
    // Extract and track topics from the conversation
    this.extractTopics(content);
    
    // Keep only last 12 messages to manage token usage while maintaining context
    if (this.messageHistory.length > 12) {
      this.messageHistory = this.messageHistory.slice(-12);
    }
  }

  extractTopics(content) {
    // Extract rule codes
    const ruleCodes = content.match(/[cC]\d{2}\.?\d{0,2}/g);
    if (ruleCodes) {
      ruleCodes.forEach(code => this.ruleTopics.add(code.toUpperCase()));
    }

    // Extract key concepts
    const conceptKeywords = [
      'roaming', 'rdm', 'vdm', 'meta', 'power', 'character', 'crew', 'gang',
      'government', 'police', 'ems', 'robbery', 'scam', 'exploit', 'ban',
      'suspension', 'appeal', 'report', 'violation', 'infraction'
    ];
    
    const lowerContent = content.toLowerCase();
    conceptKeywords.forEach(keyword => {
      if (lowerContent.includes(keyword)) {
        this.concepts.add(keyword);
      }
    });
  }

  resetTimeout() {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
    
    this.timeout = setTimeout(() => {
      if (activeConversations.has(this.userId)) {
        this.end('timeout');
      }
    }, CONVERSATION_TIMEOUT);
  }

  end(reason = 'manual') {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
    
    const duration = Math.round((Date.now() - this.startTime) / 1000);
    const topicsDiscussed = Array.from(this.ruleTopics).concat(Array.from(this.concepts));
    
    console.log(`ğŸ“ Enhanced conversation ended (${reason})`);
    console.log(`   ğŸ‘¤ User: ${this.userId}`);
    console.log(`   â±ï¸  Duration: ${duration}s`);
    console.log(`   ğŸ’¬ Messages: ${this.messageHistory.length}`);
    console.log(`   ğŸ“‹ Topics: ${topicsDiscussed.join(', ') || 'None'}`);
    
    activeConversations.delete(this.userId);
    
    if (reason === 'timeout') {
      const channel = client.channels.cache.get(this.channelId);
      if (channel) {
        let timeoutMessage = 'Our conversation has ended due to inactivity.';
        
        // Add helpful context based on what was discussed
        if (this.ruleTopics.size > 0) {
          timeoutMessage += `\n\nWe discussed rules: ${Array.from(this.ruleTopics).join(', ')}`;
        }
        
        timeoutMessage += '\n\nPing me again if you need more help with Lucid City RP rules.';
        
        channel.send(timeoutMessage).catch(console.error);
      }
    }
  }

  getHistory() {
    return this.messageHistory;
  }

  getConversationContext() {
    return {
      ruleTopics: Array.from(this.ruleTopics),
      concepts: Array.from(this.concepts),
      duration: Date.now() - this.startTime,
      messageCount: this.messageHistory.length
    };
  }
}

// Bot ready event
client.once('ready', async () => {
  console.log('ğŸ¤– Lucid City RP Enhanced Community Assistant is online!');
  console.log(`   ğŸ“Š Logged in as: ${client.user.tag}`);
  console.log(`   ğŸ  Serving ${client.guilds.cache.size} guild(s)`);
  console.log(`   ğŸ‘¥ Ready to help ${client.users.cache.size} user(s)`);
  
  // Test enhanced rule system
  try {
    const stats = enhancedGptHandler.getParserStats();
    console.log('ğŸ“‹ Enhanced Rule System Stats:');
    console.log(`   ğŸ“œ Total Rules: ${stats.totalRules}`);
    console.log(`   ğŸ›ï¸  Community Rules: ${stats.communityRules}`);
    console.log(`   ğŸ‘¥ Crew Rules: ${stats.crewRules}`);
    console.log(`   ğŸ”— Relationships: ${stats.relationships}`);
    console.log(`   ğŸ’¡ Concepts: ${stats.concepts}`);
    console.log('   ğŸ§  Enhanced understanding system loaded!');
    
    // Test GPT connection
    const gptStatus = await enhancedGptHandler.testConnection();
    console.log(`   ğŸ¤– GPT-4 Connection: ${gptStatus ? 'âœ… Active' : 'âŒ Failed'}`);
    
  } catch (error) {
    console.error('âŒ Error initializing enhanced systems:', error);
    console.log('âš ï¸  Falling back to basic functionality');
  }
  
  console.log('   ğŸ’¬ Enhanced conversational mode active - ping me to start!');
  
  // Set bot activity
  client.user.setActivity('Enhanced Rule Assistant | Ping me!', { type: ActivityType.Watching });
});

// Handle messages with enhanced processing
client.on('messageCreate', async message => {
  if (message.author.bot || message.system) return;

  const userId = message.author.id;
  const channelId = message.channel.id;
  const isBotMentioned = message.mentions.has(client.user);
  const hasActiveConversation = activeConversations.has(userId);

  try {
    // Check for conversation end command
    if (hasActiveConversation && message.content.trim().toLowerCase() === 'end') {
      const session = activeConversations.get(userId);
      const context = session.getConversationContext();
      session.end('manual');
      
      let endMessage = 'Conversation ended. Thanks for using the enhanced rule assistant!';
      
      // Add summary if substantial conversation occurred
      if (context.messageCount > 4) {
        endMessage += `\n\nConversation Summary:`;
        endMessage += `\nâ€¢ Duration: ${Math.round(context.duration / 1000)}s`;
        endMessage += `\nâ€¢ Messages: ${context.messageCount}`;
        
        if (context.ruleTopics.length > 0) {
          endMessage += `\nâ€¢ Rules discussed: ${context.ruleTopics.join(', ')}`;
        }
        
        if (context.concepts.length > 0) {
          endMessage += `\nâ€¢ Topics covered: ${context.concepts.slice(0, 5).join(', ')}`;
        }
      }
      
      endMessage += '\n\nPing me anytime for more rule assistance!';
      
      return await message.reply(endMessage);
    }

    // Start new conversation
    if (isBotMentioned && !hasActiveConversation) {
      const session = new EnhancedConversationSession(userId, channelId);
      activeConversations.set(userId, session);
      
      console.log(`ğŸ’¬ Enhanced conversation started`);
      console.log(`   ğŸ‘¤ User: ${message.author.tag} (${userId})`);
      console.log(`   ğŸ  Server: ${message.guild?.name || 'DM'}`);
      
      const userMessage = message.content.replace(`<@${client.user.id}>`, '').trim();
      session.addMessage('user', userMessage);
      
      await message.channel.sendTyping();
      
      // Get enhanced AI response
      const response = await enhancedGptHandler.handleConversation(userMessage, session.getHistory(), {
        isNewConversation: true,
        userName: message.author.displayName || message.author.username,
        guildName: message.guild?.name || 'Direct Message',
        guildId: message.guild?.id || null,
        userId: userId
      });
      
      session.addMessage('assistant', response);
      
      await message.reply(`${response}\n\n*Enhanced rule assistance active. Type "End" to finish our conversation.*`);
      return;
    }

    // Continue existing conversation
    if (hasActiveConversation && !isBotMentioned) {
      const session = activeConversations.get(userId);
      
      if (session.channelId !== channelId) {
        return; // Ignore messages in other channels
      }
      
      session.addMessage('user', message.content);
      
      await message.channel.sendTyping();
      
      // Get enhanced AI response with conversation context
      const response = await enhancedGptHandler.handleConversation(message.content, session.getHistory(), {
        isNewConversation: false,
        userName: message.author.displayName || message.author.username,
        guildName: message.guild?.name || 'Direct Message',
        guildId: message.guild?.id || null,
        userId: userId,
        conversationContext: session.getConversationContext()
      });
      
      session.addMessage('assistant', response);
      
      await message.reply(response);
      return;
    }

    // Handle bot mention in different channel while conversation active
    if (isBotMentioned && hasActiveConversation) {
      const session = activeConversations.get(userId);
      if (session.channelId !== channelId) {
        const context = session.getConversationContext();
        let contextMessage = `I'm already chatting with you in <#${session.channelId}>. `;
        
        if (context.ruleTopics.length > 0) {
          contextMessage += `We're discussing: ${context.ruleTopics.slice(0, 3).join(', ')}. `;
        }
        
        contextMessage += 'Continue our conversation there, or type "End" there to start a new one here.';
        
        await message.reply(contextMessage);
      }
      return;
    }

    // Handle rule lookup commands even without active conversation
    if (message.content.match(/^![cC]\d{2}\.\d{2}/) || message.content.startsWith('!rule ')) {
      await message.channel.sendTyping();
      
      const ruleQuery = message.content.replace(/^!/, '').trim();
      
      try {
        const searchResults = enhancedGptHandler.testRuleSearch(ruleQuery);
        
        if (searchResults.primary.length > 0) {
          const topResult = searchResults.primary[0];
          const rule = topResult.rule;
          
          const embed = new EmbedBuilder()
            .setTitle(`${rule.code} - ${rule.title}`)
            .setDescription(rule.description)
            .setColor(0x3498db)
            .addFields([
              {
                name: 'Section',
                value: rule.section ? `${rule.section.number} - ${rule.section.title}` : 'N/A',
                inline: true
              },
              {
                name: 'Type',
                value: rule.type === 'community' ? 'Community Rule' : 'Crew Rule',
                inline: true
              },
              {
                name: 'Severity',
                value: rule.severity ? `Level ${rule.severity}` : 'Variable',
                inline: true
              }
            ]);
          
          if (rule.infractions.length > 0) {
            embed.addFields([{
              name: 'Infractions',
              value: rule.infractions.flat().join(' â†’ '),
              inline: false
            }]);
          }
          
          if (rule.examples.length > 0) {
            embed.addFields([{
              name: 'Examples',
              value: rule.examples.slice(0, 2).join('\nâ€¢ '),
              inline: false
            }]);
          }
          
          await message.reply({ 
            embeds: [embed],
            content: 'Quick rule lookup (ping me for detailed discussion)'
          });
        } else {
          await message.reply('Rule not found. Ping me to start a conversation for help finding what you need.');
        }
      } catch (error) {
        console.error('Rule lookup error:', error);
        await message.reply('Error looking up rule. Ping me to start a conversation for assistance.');
      }
      return;
    }

  } catch (error) {
    console.error('âŒ Enhanced message handling error:', error);
    
    try {
      let errorMessage = 'I encountered an error processing your message.';
      
      // Provide more specific error guidance
      if (error.message.includes('API')) {
        errorMessage += ' I\'m having trouble with my AI processing. Try again in a moment.';
      } else if (error.message.includes('timeout')) {
        errorMessage += ' The request timed out. Please try a shorter message.';
      } else {
        errorMessage += ' Contact staff if this persists.';
      }
      
      await message.reply(errorMessage);
    } catch (replyError) {
      console.error('âŒ Failed to send error message:', replyError);
    }
  }
});

// Enhanced guild join with rule system info
client.on('guildCreate', guild => {
  console.log(`ğŸ“ˆ Joined new guild: ${guild.name} (${guild.id}) with ${guild.memberCount} members`);
  
  if (guild.systemChannel) {
    const welcomeMessage = `**Lucid City RP Enhanced Assistant Has Arrived**

I am an advanced AI assistant with deep understanding of Lucid City RP rules and procedures.

**Enhanced Capabilities:**
ğŸ§  Deep rule understanding with context and relationships
ğŸ” Intelligent rule search and explanations
ğŸ“‹ Comprehensive infraction and consequence information
ğŸ”— Related rule suggestions and concept explanations

**How to Use Me:**
â€¢ **Ping me** (@${client.user.displayName}) to start an intelligent conversation
â€¢ **Quick lookup:** \`!C##.##\` or \`!rule [search]\` for instant rule info
â€¢ **Smart discussions:** I understand rule concepts and relationships

**Conversation Features:**
â€¢ Context-aware responses that build on previous discussion
â€¢ Automatic topic tracking and rule relationship identification
â€¢ Comprehensive explanations with examples and consequences
â€¢ Type "End" to finish any conversation

**What I Excel At:**
â€¢ Complex rule interpretations and edge cases
â€¢ Understanding how multiple rules interact
â€¢ Explaining the reasoning behind rules
â€¢ Infraction progressions and appeal processes
â€¢ Finding related rules you might not have considered

**Official Support:**
â€¢ Reports: <#790344631048208435> or <#794297874070241301>
â€¢ Appeals: https://forums.lucidcityrp.com/forms/29-20-ban-appeal/

Ready to provide enhanced rule assistance with true understanding!`;

    guild.systemChannel.send(welcomeMessage).catch(() => {
      console.log(`Could not send enhanced welcome message to ${guild.name}`);
    });
  }
});

client.on('guildDelete', guild => {
  console.log(`ğŸ“‰ Left guild: ${guild.name} (${guild.id})`);
});

// Enhanced shutdown process
process.on('SIGINT', () => {
  console.log('ğŸ”„ Shutting down enhanced assistant gracefully...');
  console.log(`ğŸ“Š Active conversations: ${activeConversations.size}`);
  
  // Enhanced conversation cleanup
  for (const [userId, session] of activeConversations) {
    const context = session.getConversationContext();
    console.log(`   ğŸ“ Ending conversation with ${userId}: ${context.messageCount} messages, ${context.ruleTopics.length} rules discussed`);
    session.end('shutdown');
  }
  
  client.destroy();
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('ğŸ”„ Received SIGTERM, enhanced shutdown in progress...');
  
  for (const [userId, session] of activeConversations) {
    session.end('shutdown');
  }
  
  client.destroy();
  process.exit(0);
});

// Enhanced error handlers
process.on('unhandledRejection', (reason, promise) => {
  console.error('âŒ Unhandled Rejection in enhanced system:', promise, 'reason:', reason);
  
  // Try to gracefully handle rule system errors
  if (reason.message && reason.message.includes('rule')) {
    console.log('ğŸ”§ Rule system error detected, continuing with basic functionality');
  }
});

process.on('uncaughtException', (error) => {
  console.error('âŒ Uncaught Exception in enhanced system:', error);
  console.log('ğŸ”„ Attempting graceful shutdown...');
  
  for (const [userId, session] of activeConversations) {
    session.end('error');
  }
  
  client.destroy();
  process.exit(1);
});

// Enhanced startup sequence
console.log('ğŸš€ Starting Lucid City RP Enhanced Community Assistant...');
console.log('ğŸ§  Loading enhanced rule understanding system...');
console.log('ğŸ’¬ Preparing intelligent conversation capabilities...');

client.login(process.env.DISCORD_TOKEN)
  .then(() => {
    console.log('âœ… Successfully logged in to Discord');
    console.log('ğŸŒŸ Enhanced rule assistant ready with deep understanding!');
    console.log('ğŸ“‹ Features: Intelligent search, concept mapping, relationship analysis');
    console.log('ğŸ” Quick commands: !C##.## for instant lookups, @mention for conversations');
  })
  .catch(error => {
    console.error('âŒ Failed to login to Discord:', error);
    process.exit(1);
  });